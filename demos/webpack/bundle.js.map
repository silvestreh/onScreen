{"version":3,"sources":["webpack:///bundle.js","webpack:///webpack/bootstrap 93ce3c743d790f9946fb","webpack:///./src/main.js","webpack:///./~/onscreen/dist/onScreen.umd.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","addClass","element","className","classes","getAttribute","setAttribute","removeClass","replace","destroy","os","osVertical","osHorizontal","attach","OnScreen","document","addEventListener","querySelector","tolerance","on","container","global","factory","this","options","HTMLElement","style","window","getComputedStyle","position","_scroll","attached","insideViewport","el","arguments","length","undefined","elRect","getBoundingClientRect","visible","bottom","right","left","innerWidth","documentElement","clientWidth","top","innerHeight","clientHeight","containerRect","offsetTop","scrollTop","offsetLeft","scrollLeft","width","height","eventHandler","trackedElements","selectors","Object","keys","forEach","selector","nodes","item","node","wasVisible","isVisible","enter","leave","debouncedScroll","_this","timeout","clearTimeout","setTimeout","throttle","removeEventListener","off","event","hasOwnProperty","callback","allowed","Error","indexOf","i","querySelectorAll","push","console","warn","observeDOM","obj","MutationObserver","WebKitMutationObserver","eventListenerSupported","obs","mutations","addedNodes","removedNodes","observe","childList","subtree","debounce","defineProperties","configurable","enumerable","get","set","value","parseInt","defineProperty","writable","_debouncedScroll","getRelativeClientRect","rect","parentRect","offsetParent","prototype"],"mappings":"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","file":"bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar OnScreen = __webpack_require__(1);\n\t\n\tfunction addClass(element, className) {\n\t    var classes = element.getAttribute('class') || '';\n\t\n\t    // Not using element.classList because is not supported in IE9\n\t    element.setAttribute('class', classes + ' ' + className);\n\t}\n\t\n\tfunction removeClass(element, className) {\n\t    var classes = element.getAttribute('class') || '';\n\t\n\t    // Not using element.classList because is not supported in IE9\n\t    element.setAttribute('class', classes.replace(' ' + className, ''));\n\t}\n\t\n\tfunction destroy() {\n\t    os.destroy();\n\t    osVertical.destroy();\n\t    osHorizontal.destroy();\n\t}\n\t\n\tfunction attach() {\n\t    os.attach();\n\t    osVertical.attach();\n\t    osHorizontal.attach();\n\t}\n\t\n\t// Document ready\n\tdocument.addEventListener('DOMContentLoaded', function () {\n\t    document.querySelector('.js-destroy').addEventListener('click', destroy);\n\t    document.querySelector('.js-attach').addEventListener('click', attach);\n\t}, false);\n\t\n\t// Container is window\n\tvar os = new OnScreen({\n\t    tolerance: 50\n\t});\n\t\n\tos.on('enter', '.target', function (element) {\n\t    // Using jQuery: $(element).addClass('onScreen');\n\t    addClass(element, 'onScreen');\n\t});\n\t\n\tos.on('leave', '.target', function (element) {\n\t    // Using jQuery: $(element).removeClass('onScreen');\n\t    removeClass(element, 'onScreen');\n\t});\n\t\n\t\n\t// Container is element (vertical orientation)\n\tvar osVertical = new OnScreen({\n\t    container: '.container .vertical',\n\t    tolerance: 20\n\t});\n\t\n\tosVertical.on('enter', '.vertical .contained', function (element) {\n\t    // You can use jQuery with $(element)\n\t    addClass(element, 'onScreen');\n\t});\n\t\n\tosVertical.on('leave', '.vertical .contained', function (element) {\n\t    // You can use jQuery with $(element)\n\t    removeClass(element, 'onScreen');\n\t});\n\t\n\t// Container is element (horizontal orientation)\n\tvar osHorizontal = new OnScreen({\n\t    container: '.container .horizontal',\n\t    tolerance: 20\n\t});\n\t\n\tosHorizontal.on('enter', '.horizontal .contained', function (element) {\n\t    // You can use jQuery with $(element)\n\t    addClass(element, 'onScreen');\n\t});\n\t\n\tosHorizontal.on('leave', '.horizontal .contained', function (element) {\n\t    // You can use jQuery with $(element)\n\t    removeClass(element, 'onScreen');\n\t});\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function (global, factory) {\n\t   true ? module.exports = factory() :\n\t  typeof define === 'function' && define.amd ? define(factory) :\n\t  (global.OnScreen = factory());\n\t}(this, function () { 'use strict';\n\t\n\t  /**\n\t   * Attaches the scroll event handler\n\t   *\n\t   * @return {void}\n\t   */\n\t  function attach() {\n\t      var container = this.options.container;\n\t\n\t      if (container instanceof HTMLElement) {\n\t          var style = window.getComputedStyle(container);\n\t\n\t          if (style.position === 'static') {\n\t              container.style.position = 'relative';\n\t          }\n\t      }\n\t\n\t      container.addEventListener('scroll', this._scroll);\n\t      window.addEventListener('resize', this._scroll);\n\t      this._scroll();\n\t      this.attached = true;\n\t  }\n\t\n\t  window.getRelativeClientRect = function getRelativeClientRect(el) {\n\t      var rect = el.getBoundingClientRect();\n\t      var parentRect = el.offsetParent.getBoundingClientRect();\n\t\n\t      return {\n\t          bottom: parentRect.bottom - rect.bottom,\n\t          height: rect.height,\n\t          left: rect.left - parentRect.left,\n\t          right: parentRect.right - rect.right,\n\t          top: rect.top - parentRect.top,\n\t          width: rect.width\n\t      };\n\t  };\n\t\n\t  /**\n\t   * Checks an element's position in respect to the viewport\n\t   * and determines wether it's inside the viewport.\n\t   *\n\t   * @param {node} element The DOM node you want to check\n\t   * @return {boolean} A boolean value that indicates wether is on or off the viewport.\n\t   */\n\t  function insideViewport(el) {\n\t      var options = arguments.length <= 1 || arguments[1] === undefined ? { tolerance: 0, container: window } : arguments[1];\n\t\n\t      if (!el) return false;\n\t\n\t      var elRect = el.getBoundingClientRect();\n\t      var visible = void 0;\n\t\n\t      if (options.container === window) {\n\t          visible =\n\t          // Check bottom boundary\n\t          elRect.bottom - options.tolerance > 0 &&\n\t\n\t          // Check right boundary\n\t          elRect.right - options.tolerance > 0 &&\n\t\n\t          // Check left boundary\n\t          elRect.left + options.tolerance < (window.innerWidth || document.documentElement.clientWidth) &&\n\t\n\t          // Check top boundary\n\t          elRect.top + options.tolerance < (window.innerHeight || document.documentElement.clientHeight);\n\t      } else {\n\t          var containerRect = options.container.getBoundingClientRect();\n\t\n\t          visible =\n\t          // // Check bottom boundary\n\t          el.offsetTop + el.clientHeight - options.tolerance > options.container.scrollTop &&\n\t\n\t          // Check right boundary\n\t          el.offsetLeft + el.clientWidth - options.tolerance > options.container.scrollLeft &&\n\t\n\t          // Check left boundary\n\t          el.offsetLeft + options.tolerance < containerRect.width + options.container.scrollLeft &&\n\t\n\t          // // Check top boundary\n\t          el.offsetTop + options.tolerance < containerRect.height + options.container.scrollTop;\n\t      }\n\t\n\t      return visible;\n\t  }\n\t\n\t  function eventHandler() {\n\t      var trackedElements = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t      var options = arguments.length <= 1 || arguments[1] === undefined ? { tolerance: 0 } : arguments[1];\n\t\n\t      var selectors = Object.keys(trackedElements);\n\t\n\t      if (!selectors.length) return;\n\t\n\t      selectors.forEach(function (selector) {\n\t          trackedElements[selector].nodes.forEach(function (item) {\n\t              if (insideViewport(item.node, options)) {\n\t                  item.wasVisible = item.isVisible;\n\t                  item.isVisible = true;\n\t              } else {\n\t                  item.wasVisible = item.isVisible;\n\t                  item.isVisible = false;\n\t              }\n\t              if (item.isVisible === true && item.wasVisible === false) {\n\t                  if (typeof trackedElements[selector].enter === 'function') {\n\t                      trackedElements[selector].enter(item.node);\n\t                  }\n\t              }\n\t              if (item.isVisible === false && item.wasVisible === true) {\n\t                  if (typeof trackedElements[selector].leave === 'function') {\n\t                      trackedElements[selector].leave(item.node);\n\t                  }\n\t              }\n\t          });\n\t      });\n\t  }\n\t\n\t  /**\n\t   * Debounces the scroll event to avoid performance issues\n\t   *\n\t   * @return {void}\n\t   */\n\t  function debouncedScroll() {\n\t      var _this = this;\n\t\n\t      var timeout = void 0;\n\t\n\t      return function () {\n\t          clearTimeout(timeout);\n\t\n\t          timeout = setTimeout(function () {\n\t              eventHandler(_this.trackedElements, _this.options);\n\t          }, _this.options.throttle);\n\t      };\n\t  }\n\t\n\t  /**\n\t   * Removes the scroll event handler\n\t   *\n\t   * @return {void}\n\t   */\n\t  function destroy() {\n\t    this.options.container.removeEventListener('scroll', this._scroll);\n\t    window.removeEventListener('resize', this._scroll);\n\t    this.attached = false;\n\t  }\n\t\n\t  /**\n\t   * Stops tracking elements matching a CSS selector. If a selector has no\n\t   * callbacks it gets removed.\n\t   *\n\t   * @param {string} event The event you want to stop tracking (enter or leave)\n\t   * @param {string} selector The CSS selector you want to stop tracking\n\t   * @return {void}\n\t   */\n\t  function off(event, selector) {\n\t      if (this.trackedElements.hasOwnProperty(selector)) {\n\t          if (this.trackedElements[selector][event]) {\n\t              delete this.trackedElements[selector][event];\n\t          }\n\t      }\n\t      if (!this.trackedElements[selector].enter && !this.trackedElements[selector].leave) {\n\t          delete this.trackedElements[selector];\n\t      }\n\t  }\n\t\n\t  /**\n\t   * Starts tracking elements matching a CSS selector\n\t   *\n\t   * @param {string} event The event you want to track (enter or leave)\n\t   * @param {string} selector The element you want to track\n\t   * @param {function} callback The callback function to handle the event\n\t   * @return {void}\n\t   */\n\t  function on(event, selector, callback) {\n\t      var allowed = ['enter', 'leave'];\n\t\n\t      if (!event) throw new Error('No event given. Choose either enter or leave');\n\t      if (!selector) throw new Error('No selector to track');\n\t      if (allowed.indexOf(event) < 0) throw new Error(event + ' event is not supported');\n\t\n\t      if (!this.trackedElements.hasOwnProperty(selector)) {\n\t          this.trackedElements[selector] = {};\n\t      }\n\t\n\t      this.trackedElements[selector].nodes = [];\n\t\n\t      for (var i = 0; i < document.querySelectorAll(selector).length; i++) {\n\t          var item = {\n\t              isVisible: false,\n\t              wasVisible: false,\n\t              node: document.querySelectorAll(selector)[i]\n\t          };\n\t\n\t          this.trackedElements[selector].nodes.push(item);\n\t      }\n\t\n\t      if (typeof this.trackedElements[selector][event] === 'function' && typeof callback === 'function') {\n\t          console.warn(selector + '\\'s ' + event + ' callback was overridden');\n\t      }\n\t\n\t      if (typeof callback === 'function') {\n\t          this.trackedElements[selector][event] = callback;\n\t      }\n\t  }\n\t\n\t  /**\n\t   * Observes DOM mutations and runs a callback function when\n\t   * detecting one.\n\t   *\n\t   * @param {node} obj The DOM node you want to observe\n\t   * @param {function} callback The callback function you want to call\n\t   * @return {void}\n\t   */\n\t  function observeDOM(obj, callback) {\n\t      var MutationObserver = window.MutationObserver || window.WebKitMutationObserver;\n\t      var eventListenerSupported = window.addEventListener;\n\t\n\t      if (MutationObserver) {\n\t          var obs = new MutationObserver(function (mutations) {\n\t              if (mutations[0].addedNodes.length || mutations[0].removedNodes.length) callback();\n\t          });\n\t\n\t          obs.observe(obj, {\n\t              childList: true,\n\t              subtree: true\n\t          });\n\t      } else if (eventListenerSupported) {\n\t          obj.addEventListener('DOMNodeInserted', callback, false);\n\t          obj.addEventListener('DOMNodeRemoved', callback, false);\n\t      }\n\t  }\n\t\n\t  /**\n\t   * Detects wether DOM nodes enter or leave the viewport\n\t   *\n\t   * @constructor\n\t   * @param {object} options The configuration object\n\t   */\n\t  function OnScreen() {\n\t      var _this = this;\n\t\n\t      var options = arguments.length <= 0 || arguments[0] === undefined ? { tolerance: 0, debounce: 100, container: window } : arguments[0];\n\t\n\t      this.options = {};\n\t      this.trackedElements = {};\n\t\n\t      Object.defineProperties(this.options, {\n\t          container: {\n\t              configurable: false,\n\t              enumerable: false,\n\t              get: function get() {\n\t                  var container = void 0;\n\t\n\t                  if (typeof options.container === 'string') {\n\t                      container = document.querySelector(options.container);\n\t                  } else if (options.container instanceof HTMLElement) {\n\t                      container = options.container;\n\t                  }\n\t\n\t                  return container || window;\n\t              },\n\t              set: function set(value) {\n\t                  options.container = value;\n\t              }\n\t          },\n\t          debounce: {\n\t              get: function get() {\n\t                  return parseInt(options.debounce, 10) || 100;\n\t              },\n\t              set: function set(value) {\n\t                  options.debounce = value;\n\t              }\n\t          },\n\t          tolerance: {\n\t              get: function get() {\n\t                  return parseInt(options.tolerance, 10) || 0;\n\t              },\n\t              set: function set(value) {\n\t                  options.tolerance = value;\n\t              }\n\t          }\n\t      });\n\t\n\t      Object.defineProperty(this, '_scroll', {\n\t          enumerable: false,\n\t          configurable: false,\n\t          writable: false,\n\t          value: this._debouncedScroll.call(this)\n\t      });\n\t\n\t      observeDOM(document.querySelector('body'), function () {\n\t          Object.keys(_this.trackedElements).forEach(function (element) {\n\t              _this.on('enter', element);\n\t              _this.on('leave', element);\n\t          });\n\t      });\n\t\n\t      this.attach();\n\t  }\n\t\n\t  Object.defineProperties(OnScreen.prototype, {\n\t      _debouncedScroll: {\n\t          configurable: false,\n\t          writable: false,\n\t          enumerable: false,\n\t          value: debouncedScroll\n\t      },\n\t      attach: {\n\t          configurable: false,\n\t          writable: false,\n\t          enumerable: false,\n\t          value: attach\n\t      },\n\t      destroy: {\n\t          configurable: false,\n\t          writable: false,\n\t          enumerable: false,\n\t          value: destroy\n\t      },\n\t      off: {\n\t          configurable: false,\n\t          writable: false,\n\t          enumerable: false,\n\t          value: off\n\t      },\n\t      on: {\n\t          configurable: false,\n\t          writable: false,\n\t          enumerable: false,\n\t          value: on\n\t      }\n\t  });\n\t\n\t  return OnScreen;\n\t\n\t}));\n\t//# sourceMappingURL=OnScreen.umd.js.map\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** bundle.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 93ce3c743d790f9946fb\n **/","var OnScreen = require('onscreen');\n\nfunction addClass(element, className) {\n    var classes = element.getAttribute('class') || '';\n\n    // Not using element.classList because is not supported in IE9\n    element.setAttribute('class', classes + ' ' + className);\n}\n\nfunction removeClass(element, className) {\n    var classes = element.getAttribute('class') || '';\n\n    // Not using element.classList because is not supported in IE9\n    element.setAttribute('class', classes.replace(' ' + className, ''));\n}\n\nfunction destroy() {\n    os.destroy();\n    osVertical.destroy();\n    osHorizontal.destroy();\n}\n\nfunction attach() {\n    os.attach();\n    osVertical.attach();\n    osHorizontal.attach();\n}\n\n// Document ready\ndocument.addEventListener('DOMContentLoaded', function () {\n    document.querySelector('.js-destroy').addEventListener('click', destroy);\n    document.querySelector('.js-attach').addEventListener('click', attach);\n}, false);\n\n// Container is window\nvar os = new OnScreen({\n    tolerance: 50\n});\n\nos.on('enter', '.target', function (element) {\n    // Using jQuery: $(element).addClass('onScreen');\n    addClass(element, 'onScreen');\n});\n\nos.on('leave', '.target', function (element) {\n    // Using jQuery: $(element).removeClass('onScreen');\n    removeClass(element, 'onScreen');\n});\n\n\n// Container is element (vertical orientation)\nvar osVertical = new OnScreen({\n    container: '.container .vertical',\n    tolerance: 20\n});\n\nosVertical.on('enter', '.vertical .contained', function (element) {\n    // You can use jQuery with $(element)\n    addClass(element, 'onScreen');\n});\n\nosVertical.on('leave', '.vertical .contained', function (element) {\n    // You can use jQuery with $(element)\n    removeClass(element, 'onScreen');\n});\n\n// Container is element (horizontal orientation)\nvar osHorizontal = new OnScreen({\n    container: '.container .horizontal',\n    tolerance: 20\n});\n\nosHorizontal.on('enter', '.horizontal .contained', function (element) {\n    // You can use jQuery with $(element)\n    addClass(element, 'onScreen');\n});\n\nosHorizontal.on('leave', '.horizontal .contained', function (element) {\n    // You can use jQuery with $(element)\n    removeClass(element, 'onScreen');\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/main.js\n ** module id = 0\n ** module chunks = 0\n **/","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.OnScreen = factory());\n}(this, function () { 'use strict';\n\n  /**\n   * Attaches the scroll event handler\n   *\n   * @return {void}\n   */\n  function attach() {\n      var container = this.options.container;\n\n      if (container instanceof HTMLElement) {\n          var style = window.getComputedStyle(container);\n\n          if (style.position === 'static') {\n              container.style.position = 'relative';\n          }\n      }\n\n      container.addEventListener('scroll', this._scroll);\n      window.addEventListener('resize', this._scroll);\n      this._scroll();\n      this.attached = true;\n  }\n\n  window.getRelativeClientRect = function getRelativeClientRect(el) {\n      var rect = el.getBoundingClientRect();\n      var parentRect = el.offsetParent.getBoundingClientRect();\n\n      return {\n          bottom: parentRect.bottom - rect.bottom,\n          height: rect.height,\n          left: rect.left - parentRect.left,\n          right: parentRect.right - rect.right,\n          top: rect.top - parentRect.top,\n          width: rect.width\n      };\n  };\n\n  /**\n   * Checks an element's position in respect to the viewport\n   * and determines wether it's inside the viewport.\n   *\n   * @param {node} element The DOM node you want to check\n   * @return {boolean} A boolean value that indicates wether is on or off the viewport.\n   */\n  function insideViewport(el) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? { tolerance: 0, container: window } : arguments[1];\n\n      if (!el) return false;\n\n      var elRect = el.getBoundingClientRect();\n      var visible = void 0;\n\n      if (options.container === window) {\n          visible =\n          // Check bottom boundary\n          elRect.bottom - options.tolerance > 0 &&\n\n          // Check right boundary\n          elRect.right - options.tolerance > 0 &&\n\n          // Check left boundary\n          elRect.left + options.tolerance < (window.innerWidth || document.documentElement.clientWidth) &&\n\n          // Check top boundary\n          elRect.top + options.tolerance < (window.innerHeight || document.documentElement.clientHeight);\n      } else {\n          var containerRect = options.container.getBoundingClientRect();\n\n          visible =\n          // // Check bottom boundary\n          el.offsetTop + el.clientHeight - options.tolerance > options.container.scrollTop &&\n\n          // Check right boundary\n          el.offsetLeft + el.clientWidth - options.tolerance > options.container.scrollLeft &&\n\n          // Check left boundary\n          el.offsetLeft + options.tolerance < containerRect.width + options.container.scrollLeft &&\n\n          // // Check top boundary\n          el.offsetTop + options.tolerance < containerRect.height + options.container.scrollTop;\n      }\n\n      return visible;\n  }\n\n  function eventHandler() {\n      var trackedElements = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n      var options = arguments.length <= 1 || arguments[1] === undefined ? { tolerance: 0 } : arguments[1];\n\n      var selectors = Object.keys(trackedElements);\n\n      if (!selectors.length) return;\n\n      selectors.forEach(function (selector) {\n          trackedElements[selector].nodes.forEach(function (item) {\n              if (insideViewport(item.node, options)) {\n                  item.wasVisible = item.isVisible;\n                  item.isVisible = true;\n              } else {\n                  item.wasVisible = item.isVisible;\n                  item.isVisible = false;\n              }\n              if (item.isVisible === true && item.wasVisible === false) {\n                  if (typeof trackedElements[selector].enter === 'function') {\n                      trackedElements[selector].enter(item.node);\n                  }\n              }\n              if (item.isVisible === false && item.wasVisible === true) {\n                  if (typeof trackedElements[selector].leave === 'function') {\n                      trackedElements[selector].leave(item.node);\n                  }\n              }\n          });\n      });\n  }\n\n  /**\n   * Debounces the scroll event to avoid performance issues\n   *\n   * @return {void}\n   */\n  function debouncedScroll() {\n      var _this = this;\n\n      var timeout = void 0;\n\n      return function () {\n          clearTimeout(timeout);\n\n          timeout = setTimeout(function () {\n              eventHandler(_this.trackedElements, _this.options);\n          }, _this.options.throttle);\n      };\n  }\n\n  /**\n   * Removes the scroll event handler\n   *\n   * @return {void}\n   */\n  function destroy() {\n    this.options.container.removeEventListener('scroll', this._scroll);\n    window.removeEventListener('resize', this._scroll);\n    this.attached = false;\n  }\n\n  /**\n   * Stops tracking elements matching a CSS selector. If a selector has no\n   * callbacks it gets removed.\n   *\n   * @param {string} event The event you want to stop tracking (enter or leave)\n   * @param {string} selector The CSS selector you want to stop tracking\n   * @return {void}\n   */\n  function off(event, selector) {\n      if (this.trackedElements.hasOwnProperty(selector)) {\n          if (this.trackedElements[selector][event]) {\n              delete this.trackedElements[selector][event];\n          }\n      }\n      if (!this.trackedElements[selector].enter && !this.trackedElements[selector].leave) {\n          delete this.trackedElements[selector];\n      }\n  }\n\n  /**\n   * Starts tracking elements matching a CSS selector\n   *\n   * @param {string} event The event you want to track (enter or leave)\n   * @param {string} selector The element you want to track\n   * @param {function} callback The callback function to handle the event\n   * @return {void}\n   */\n  function on(event, selector, callback) {\n      var allowed = ['enter', 'leave'];\n\n      if (!event) throw new Error('No event given. Choose either enter or leave');\n      if (!selector) throw new Error('No selector to track');\n      if (allowed.indexOf(event) < 0) throw new Error(event + ' event is not supported');\n\n      if (!this.trackedElements.hasOwnProperty(selector)) {\n          this.trackedElements[selector] = {};\n      }\n\n      this.trackedElements[selector].nodes = [];\n\n      for (var i = 0; i < document.querySelectorAll(selector).length; i++) {\n          var item = {\n              isVisible: false,\n              wasVisible: false,\n              node: document.querySelectorAll(selector)[i]\n          };\n\n          this.trackedElements[selector].nodes.push(item);\n      }\n\n      if (typeof this.trackedElements[selector][event] === 'function' && typeof callback === 'function') {\n          console.warn(selector + '\\'s ' + event + ' callback was overridden');\n      }\n\n      if (typeof callback === 'function') {\n          this.trackedElements[selector][event] = callback;\n      }\n  }\n\n  /**\n   * Observes DOM mutations and runs a callback function when\n   * detecting one.\n   *\n   * @param {node} obj The DOM node you want to observe\n   * @param {function} callback The callback function you want to call\n   * @return {void}\n   */\n  function observeDOM(obj, callback) {\n      var MutationObserver = window.MutationObserver || window.WebKitMutationObserver;\n      var eventListenerSupported = window.addEventListener;\n\n      if (MutationObserver) {\n          var obs = new MutationObserver(function (mutations) {\n              if (mutations[0].addedNodes.length || mutations[0].removedNodes.length) callback();\n          });\n\n          obs.observe(obj, {\n              childList: true,\n              subtree: true\n          });\n      } else if (eventListenerSupported) {\n          obj.addEventListener('DOMNodeInserted', callback, false);\n          obj.addEventListener('DOMNodeRemoved', callback, false);\n      }\n  }\n\n  /**\n   * Detects wether DOM nodes enter or leave the viewport\n   *\n   * @constructor\n   * @param {object} options The configuration object\n   */\n  function OnScreen() {\n      var _this = this;\n\n      var options = arguments.length <= 0 || arguments[0] === undefined ? { tolerance: 0, debounce: 100, container: window } : arguments[0];\n\n      this.options = {};\n      this.trackedElements = {};\n\n      Object.defineProperties(this.options, {\n          container: {\n              configurable: false,\n              enumerable: false,\n              get: function get() {\n                  var container = void 0;\n\n                  if (typeof options.container === 'string') {\n                      container = document.querySelector(options.container);\n                  } else if (options.container instanceof HTMLElement) {\n                      container = options.container;\n                  }\n\n                  return container || window;\n              },\n              set: function set(value) {\n                  options.container = value;\n              }\n          },\n          debounce: {\n              get: function get() {\n                  return parseInt(options.debounce, 10) || 100;\n              },\n              set: function set(value) {\n                  options.debounce = value;\n              }\n          },\n          tolerance: {\n              get: function get() {\n                  return parseInt(options.tolerance, 10) || 0;\n              },\n              set: function set(value) {\n                  options.tolerance = value;\n              }\n          }\n      });\n\n      Object.defineProperty(this, '_scroll', {\n          enumerable: false,\n          configurable: false,\n          writable: false,\n          value: this._debouncedScroll.call(this)\n      });\n\n      observeDOM(document.querySelector('body'), function () {\n          Object.keys(_this.trackedElements).forEach(function (element) {\n              _this.on('enter', element);\n              _this.on('leave', element);\n          });\n      });\n\n      this.attach();\n  }\n\n  Object.defineProperties(OnScreen.prototype, {\n      _debouncedScroll: {\n          configurable: false,\n          writable: false,\n          enumerable: false,\n          value: debouncedScroll\n      },\n      attach: {\n          configurable: false,\n          writable: false,\n          enumerable: false,\n          value: attach\n      },\n      destroy: {\n          configurable: false,\n          writable: false,\n          enumerable: false,\n          value: destroy\n      },\n      off: {\n          configurable: false,\n          writable: false,\n          enumerable: false,\n          value: off\n      },\n      on: {\n          configurable: false,\n          writable: false,\n          enumerable: false,\n          value: on\n      }\n  });\n\n  return OnScreen;\n\n}));\n//# sourceMappingURL=OnScreen.umd.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/onscreen/dist/onScreen.umd.js\n ** module id = 1\n ** module chunks = 0\n **/"],"sourceRoot":""}